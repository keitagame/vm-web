<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>by keita</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        background:black;
        font-family: ui-sans-serif, system-ui;
        margin: 16px;
      }
      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
      }
      canvas {
        image-rendering: pixelated;
        border: 1px solid #ccc;
        background: #000;
      }
      .row {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
      small {
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <header>
      <input id="bin" type="file" accept=".bin" />
      <button id="fullscreenBtn">Fullscreen</button>
      <button id="stepBtn" disabled>Step</button>

      <button id="start" disabled>Start</button>
      <div class="mono" id="status">No bin</div>
      <input type="text" id="myInput" value="30" />
    </header>
    <div class="row">
      <canvas id="screen" width="854" height="480"></canvas>
      <div>
        <div><b>FPS:</b> <span id="fps">0</span></div>
        <div><b>CPU PC:</b> <span id="pc" class="mono">0x0000</span></div>
        <div><b>Cycles:</b> <span id="cyc" class="mono">0</span></div>
        <div><b>VRAM V:</b><span id="pcp" class="mono">0x0000</span></div>
        <div><b>VRAM T:</b><span id="ppx" class="mono">0x0000</span></div>

        <small></small>
      </div>
    </div>

    by.keita

    <script type="module">
      // x86 16-bit real-mode emulator (subset)
      // Put this inside <script type="module"> in your HTML.
      // Minimal 80x25 TTY text renderer for INT 10h AH=0x0E
      class VideoTTY {
        constructor(canvas, opts = {}) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d", { alpha: false });

          // 80x25 テキストモード
          this.cols = opts.cols ?? 80;
          this.rows = opts.rows ?? 25;

          // セルサイズ（キャンバスと見栄えに合わせて調整可）
          this.charW = opts.charW ?? 10; // 80*10 = 800
          this.charH = opts.charH ?? 18; // 25*18 = 450

          // キャンバスサイズへ合わせる
          this.canvas.width = this.cols * this.charW;
          this.canvas.height = this.rows * this.charH;

          // フォントと色
          this.font =
            opts.font ??
            "16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
          this.fg = opts.fg ?? "#dcdcdc";
          this.bg = opts.bg ?? "#000000";

          // カーソル位置
          this.cx = 0; // column
          this.cy = 0; // row

          // 背景を塗って初期化
          this.clear();
        }

        setTextMode(mode) {
          // 今回は mode=3（80x25 テキスト）だけ対応
          if (mode !== 3) {
            // 互換目的で無視しても良いが、ここでは同じ挙動に。
          }
          this.cols = 80;
          this.rows = 25;
          this.charW = 10;
          this.charH = 18;
          this.canvas.width = this.cols * this.charW;
          this.canvas.height = this.rows * this.charH;
          this.cx = 0;
          this.cy = 0;
          this.clear();
        }

        clear() {
          this.ctx.fillStyle = this.bg;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        drawCell(x, y, ch, fg = this.fg, bg = this.bg) {
          const px = x * this.charW;
          const py = y * this.charH;

          // 背景
          this.ctx.fillStyle = bg;
          this.ctx.fillRect(px, py, this.charW, this.charH);

          // 文字
          if (ch !== null && ch !== undefined && ch >= 0x20) {
            this.ctx.font = this.font;
            this.ctx.textBaseline = "top";
            this.ctx.fillStyle = fg;

            // 横位置は微調整（セル中央寄せ）
            // 文字幅が可変でも見やすいように左余白を少し取る
            const xOffset = 1;
            const yOffset = 1;
            this.ctx.fillText(
              String.fromCharCode(ch),
              px + xOffset,
              py + yOffset
            );
          }
        }

        scroll() {
          const { canvas, ctx, charH, bg } = this;
          const w = canvas.width,
            h = canvas.height;

          // 1行分を上へコピー
          const img = ctx.getImageData(0, charH, w, h - charH);
          ctx.putImageData(img, 0, 0);

          // 最下行をクリア
          ctx.fillStyle = bg;
          ctx.fillRect(0, h - charH, w, charH);
        }

        putCharTTY(ch) {
          // BIOS TTY の主な制御コードを処理
          if (ch === 0x08) {
            // Backspace
            if (this.cx > 0) {
              this.cx--;
              this.drawCell(this.cx, this.cy, 0x20); // 空白で消す
            }
            return;
          }
          if (ch === 0x0d) {
            // CR
            this.cx = 0;
            return;
          }
          if (ch === 0x0a) {
            // LF
            this.cy++;
            if (this.cy >= this.rows) {
              this.scroll();
              this.cy = this.rows - 1;
            }
            return;
          }
          if (ch === 0x09) {
            // Tab → 8桁タブ
            const nextTab = (Math.floor(this.cx / 8) + 1) * 8;
            while (this.cx < nextTab && this.cx < this.cols) {
              this.drawCell(this.cx, this.cy, 0x20);
              this.cx++;
            }
            return;
          }

          // 印字可能文字（ASCII 0x20〜0x7E程度）
          if (ch >= 0x20 && ch <= 0x7e) {
            this.drawCell(this.cx, this.cy, ch);
            this.cx++;
            if (this.cx >= this.cols) {
              this.cx = 0;
              this.cy++;
              if (this.cy >= this.rows) {
                this.scroll();
                this.cy = this.rows - 1;
              }
            }
            return;
          }

          // 未対応制御コードは無視
        }
      }
      // 偶数パリティなら true を返す
      function parity8(x) {
        x &= 0xff;
        let ones = 0;
        for (let i = 0; i < 8; i++) {
          ones += (x >> i) & 1;
        }
        return ones % 2 === 0;
      }
      class Keyboard {
        constructor() {
          this.buffer = [];
          this.scancodeMap = {
            // control keys
            Enter: 0x1c,
            Backspace: 0x0e,
            Space: 0x39,
            Tab: 0x0f,
            Escape: 0x01,
            // digits (top row)
            Digit0: 0x0b,
            Digit1: 0x02,
            Digit2: 0x03,
            Digit3: 0x04,
            Digit4: 0x05,
            Digit5: 0x06,
            Digit6: 0x07,
            Digit7: 0x08,
            Digit8: 0x09,
            Digit9: 0x0a,
            // letters (US layout)
            KeyA: 0x1e,
            KeyB: 0x30,
            KeyC: 0x2e,
            KeyD: 0x20,
            KeyE: 0x12,
            KeyF: 0x21,
            KeyG: 0x22,
            KeyH: 0x23,
            KeyI: 0x17,
            KeyJ: 0x24,
            KeyK: 0x25,
            KeyL: 0x26,
            KeyM: 0x32,
            KeyN: 0x31,
            KeyO: 0x18,
            KeyP: 0x19,
            KeyQ: 0x10,
            KeyR: 0x13,
            KeyS: 0x1f,
            KeyT: 0x14,
            KeyU: 0x16,
            KeyV: 0x2f,
            KeyW: 0x11,
            KeyX: 0x2d,
            KeyY: 0x15,
            KeyZ: 0x2c,
          };

          document.addEventListener(
            "keydown",
            (e) => {
              // Skip IME composition and pure modifier keys
              if (
                e.isComposing ||
                e.key === "Shift" ||
                e.key === "Control" ||
                e.key === "Alt"
              )
                return;

              // ASCII
              let ascii = 0;
              if (e.key.length === 1) {
                ascii = e.key.charCodeAt(0);
              } else if (e.key === "Enter") {
                ascii = 0x0d;
              } else if (e.key === "Backspace") {
                ascii = 0x08;
              } else if (e.key === "Tab") {
                ascii = 0x09;
              } else if (e.key === "Escape") {
                ascii = 0x1b;
              } else if (e.key === " ") {
                ascii = 0x20;
              }

              // Scancode (set 1)
              const scancode = this.scancodeMap[e.code] ?? 0;

              // Push only meaningful keys
              if (ascii !== 0 || scancode !== 0) {
                this.buffer.push({ ascii, scancode });
                e.preventDefault();
              }
            },
            { capture: true }
          );
        }

        // Non-blocking: return next key or null
        getKeyBlocking() {
          return this.buffer.length ? this.buffer.shift() : null;
        }

        // Peek for AH=01 without consuming
        peek() {
          return this.buffer.length ? this.buffer[0] : null;
        }
      }

      // エミュレータに組み込む

      class CPU8086 {
        constructor(memSize = 0x100000) {
          this.mem = new Uint8Array(memSize);
          this.reset();
        }

        reset() {
          this.regs = {
            AX: 0,
            BX: 0,
            CX: 0,
            DX: 0,
            SP: 0xfffe,
            BP: 0,
            CS: 0,
            DS: 0,
            ES: 0,
            SS: 0,
            SI: 0,
            DI: 0,
            IP: 0, // Instruction Pointer (we ignore CS for simplicity)
          };
          this.FLAGS = 0; // bitmask: CF=1<<0, PF=1<<2, AF=1<<4, ZF=1<<6, SF=1<<7, OF=1<<11
          this.cycles = 0;
          this.halted = false;

          this.kbd = new Keyboard();
        }

        // エミュレータに組み込む

        getZF() {
          return ((this.FLAGS >> 6) & 1) !== 0;
        }
        // Helpers
        read8(addr) {
          return this.mem[addr & 0xfffff];
        }
        write8(addr, v) {
          this.mem[addr & 0xfffff] = v & 0xff;
        }
        read16(addr) {
          const a = addr & 0xfffff;
          return this.mem[a] | (this.mem[(a + 1) & 0xfffff] << 8);
        }
        write16(addr, val) {
          const a = addr & 0xfffff;
          this.mem[a] = val & 0xff;
          this.mem[(a + 1) & 0xfffff] = (val >> 8) & 0xff;
        }
        fetch8() {
          const phys = ((this.regs.CS << 4) + this.regs.IP) & 0xfffff;
          const v = this.read8(phys);
          this.regs.IP = (this.regs.IP + 1) & 0xffff;
          return v;
        }

        fetch16() {
          const lo = this.fetch8();
          const hi = this.fetch8();
          return lo | (hi << 8);
        }

        sign8(v) {
          return v & 0x80 ? v - 0x100 : v;
        }
        sign16(v) {
          return v & 0x8000 ? v - 0x10000 : v;
        }

        // Flags: set for 16-bit results
        setFlagsArith16(op, a, b, r) {
          const res = r & 0xffff;
          const signedA = a & 0xffff;
          const signedB = b & 0xffff;
          const carryAdd = signedA + signedB > 0xffff;
          const carrySub = signedA - signedB < 0;
          const cf =
            op === "add"
              ? carryAdd
              : op === "sub"
              ? carrySub
              : op === "cmp"
              ? carrySub
              : 0;
          const zf = res === 0 ? 1 : 0;
          const sf = res & 0x8000 ? 1 : 0;
          const of = (() => {
            const sa = (signedA & 0x8000) !== 0;
            const sb = (signedB & 0x8000) !== 0;
            const sr = (res & 0x8000) !== 0;
            if (op === "add") return sa === sb && sa !== sr ? 1 : 0;
            if (op === "sub" || op === "cmp")
              return sa !== sb && sa !== sr ? 1 : 0;
            return 0;
          })();
          // Simplified PF/AF not fully accurate; we set AF by low nibble carry/borrow
          const af =
            op === "add"
              ? (signedA & 0xf) + (signedB & 0xf) > 0xf
                ? 1
                : 0
              : op === "sub" || op === "cmp"
              ? (signedA & 0xf) - (signedB & 0xf) < 0
                ? 1
                : 0
              : 0;
          // Parity for low byte
          const parity = (x) => {
            x &= 0xff;
            let ones = 0;
            for (let i = 0; i < 8; i++) ones += (x >> i) & 1;
            return ones % 2 === 0 ? 1 : 0;
          };
          const pf = parity(res);

          // Update FLAGS bits
          const maskCF = 1 << 0,
            maskPF = 1 << 2,
            maskAF = 1 << 4,
            maskZF = 1 << 6,
            maskSF = 1 << 7,
            maskOF = 1 << 11;
          this.FLAGS =
            (this.FLAGS &
              ~(maskCF | maskPF | maskAF | maskZF | maskSF | maskOF)) |
            (cf ? maskCF : 0) |
            (pf ? maskPF : 0) |
            (af ? maskAF : 0) |
            (zf ? maskZF : 0) |
            (sf ? maskSF : 0) |
            (of ? maskOF : 0);
          return res;
        }

        // Register helpers
        rIndexToName(i) {
          return ["AX", "CX", "DX", "BX", "SP", "BP", "SI", "DI"][i & 7];
        }

        getReg16(name) {
          return this.regs[name] & 0xffff;
        }
        setReg16(name, v) {
          this.regs[name] = v & 0xffff;
        }
        getDF() {
          return ((this.FLAGS >> 10) & 1) !== 0;
        }
        // ModR/M decoding for 16-bit addressing
        decodeModRM() {
          const modrm = this.fetch8();
          const mod = (modrm >> 6) & 3;
          const reg = (modrm >> 3) & 7;
          const rm = modrm & 7;

          // Effective address calculation
          const getEA = () => {
            const baseCalc = (rmVal) => {
              const R = this.regs;
              switch (rmVal) {
                case 0:
                  return (R.BX + R.SI) & 0xffff;
                case 1:
                  return (R.BX + R.DI) & 0xffff;
                case 2:
                  return (R.BP + R.SI) & 0xffff;
                case 3:
                  return (R.BP + R.DI) & 0xffff;
                case 4:
                  return R.SI & 0xffff;
                case 5:
                  return R.DI & 0xffff;
                case 6:
                  return R.BP & 0xffff;
                case 7:
                  return R.BX & 0xffff;
              }
            };

            let ea;
            if (mod === 0) {
              if (rm === 6) {
                // disp16 only
                const disp = this.fetch16();
                ea = disp;
              } else {
                ea = baseCalc(rm);
              }
            } else if (mod === 1) {
              const disp8 = this.sign8(this.fetch8());
              ea = (baseCalc(rm) + disp8) & 0xffff;
            } else if (mod === 2) {
              const disp16 = this.fetch16();
              ea = (baseCalc(rm) + disp16) & 0xffff;
            } else {
              // mod==3 => register-direct
              ea = null; // indicates register-direct
            }
            return { mod, reg, rm, ea };
          };
          return getEA();
        }

        readOperand16(mod, rm, ea) {
          if (mod === 3) {
            const rn = this.rIndexToName(rm);
            return this.getReg16(rn);
          }
          return this.read16(ea);
        }

        writeOperand16(mod, rm, ea, v) {
          if (mod === 3) {
            const rn = this.rIndexToName(rm);
            this.setReg16(rn, v);
          } else {
            this.write16(ea, v);
          }
        }
        getReg8(index) {
          switch (index & 7) {
            case 0:
              return this.regs.AX & 0xff; // AL
            case 1:
              return this.regs.CX & 0xff; // CL
            case 2:
              return this.regs.DX & 0xff; // DL
            case 3:
              return this.regs.BX & 0xff; // BL
            case 4:
              return (this.regs.AX >> 8) & 0xff; // AH
            case 5:
              return (this.regs.CX >> 8) & 0xff; // CH
            case 6:
              return (this.regs.DX >> 8) & 0xff; // DH
            case 7:
              return (this.regs.BX >> 8) & 0xff; // BH
          }
        }
        setReg8(index, val) {
          val &= 0xff;
          switch (index & 7) {
            case 0:
              this.regs.AX = (this.regs.AX & 0xff00) | val;
              break; // AL
            case 1:
              this.regs.CX = (this.regs.CX & 0xff00) | val;
              break; // CL
            case 2:
              this.regs.DX = (this.regs.DX & 0xff00) | val;
              break; // DL
            case 3:
              this.regs.BX = (this.regs.BX & 0xff00) | val;
              break; // BL
            case 4:
              this.regs.AX = (this.regs.AX & 0x00ff) | (val << 8);
              break; // AH
            case 5:
              this.regs.CX = (this.regs.CX & 0x00ff) | (val << 8);
              break; // CH
            case 6:
              this.regs.DX = (this.regs.DX & 0x00ff) | (val << 8);
              break; // DH
            case 7:
              this.regs.BX = (this.regs.BX & 0x00ff) | (val << 8);
              break; // BH
          }
        }
        setFlagsLogical(r, width) {
          const maskCF = 1 << 0,
            maskPF = 1 << 2,
            maskZF = 1 << 6,
            maskSF = 1 << 7,
            maskOF = 1 << 11;
          const max = width === 8 ? 0xff : 0xffff;
          const res = r & max;
          const zf = res === 0 ? 1 : 0;
          const sf = width === 8 ? (res >> 7) & 1 : (res >> 15) & 1;
          let x = res & 0xff,
            ones = 0;
          for (let i = 0; i < 8; i++) ones += (x >> i) & 1;
          const pf = ones % 2 === 0 ? 1 : 0;
          this.FLAGS =
            (this.FLAGS & ~(maskCF | maskPF | maskZF | maskSF | maskOF)) |
            (pf ? maskPF : 0) |
            (zf ? maskZF : 0) |
            (sf ? maskSF : 0);
        }
        // パリティ計算（偶数パリティなら1）
        parity8(x) {
          x &= 0xff;
          let ones = 0;
          for (let i = 0; i < 8; i++) ones += (x >> i) & 1;
          return ones % 2 === 0 ? 1 : 0;
        }

        setFlagsArith8 = function (op, a, b, res) {
          // マスク等
          a &= 0xff;
          b &= 0xff;
          res &= 0xff;
          const CF = 1 << 0,
            PF = 1 << 2,
            AF = 1 << 4,
            ZF = 1 << 6,
            SF = 1 << 7,
            OF = 1 << 11;

          // 共通: ZF, SF, PF 更新
          let flags = this.FLAGS & ~(CF | PF | AF | ZF | SF | OF);
          if (res === 0) flags |= ZF;
          if (res & 0x80) flags |= SF;
          if (parity8(res)) flags |= PF;

          // AF: 下位ニブルのキャリー/ボロー
          const afSet = ((a ^ b ^ res) & 0x10) !== 0;

          // OF/CF は演算種類で異なる
          if (op === "add") {
            // CF: 加算キャリー
            const cfSet = a + b > 0xff;
            // OF: 符号付きオーバーフロー
            const ofSet = (~(a ^ b) & (a ^ res) & 0x80) !== 0;

            if (cfSet) flags |= CF;
            if (afSet) flags |= AF;
            if (ofSet) flags |= OF;
          } else if (op === "sub" || op === "cmp") {
            // CF: 減算ボロー（a < b）
            const cfSet = a < b;
            // OF: 符号付きオーバーフロー
            const ofSet = ((a ^ b) & (a ^ res) & 0x80) !== 0;

            if (cfSet) flags |= CF;
            if (afSet) flags |= AF;
            if (ofSet) flags |= OF;
          } else if (op === "test") {
            // TEST は論理演算と同様に CF=OF=0, AFは触らない（一般に未定義）
            // 既に ZF/SF/PF は設定済み
          } else {
            // 必要なら他の算術に拡張
          }

          this.FLAGS = flags;
        };

        handleInt10() {
          console.log("INT 10h", this.regs.AX.toString(16));
          const ah = (this.regs.AX >> 8) & 0xff;
          if (ah === 0x00) {
            // set video mode AL=0x03 を受けて画面クリア・状態初期化
            this.video.setTextMode(3);
            return;
          }
          if (ah === 0x0e) {
            const ch = this.regs.AX & 0xff; // AL
            this.video.putCharTTY(ch); // キャンバスに描画（カーソル進める）
            return;
          }
          // 他は必要に応じて
        }
        handleInt16() {
          const AH = (this.regs.AX >> 8) & 0xff;

          if (AH === 0x00) {
            // Read key (blocking)
            const key = this.kbd.getKeyBlocking();
            if (!key) {
              // No key yet: emulate block by doing nothing this step
              // Program will re-enter INT 16h next frame
              return;
            }
            this.regs.AX = ((key.scancode & 0xff) << 8) | (key.ascii & 0xff);
            return;
          }

          if (AH === 0x01) {
            // Check keystroke (non-blocking)
            const key = this.kbd.peek();
            if (key) {
              this.regs.AX = ((key.scancode & 0xff) << 8) | (key.ascii & 0xff);
              this.FLAGS &= ~(1 << 6); // ZF=0
            } else {
              this.FLAGS |= 1 << 6; // ZF=1
            }
            return;
          }

          // Optionally implement AH=0x02 (get shift flags), etc.
        }

        handleInt15() {
          console.log("INT 15h", this.regs.AX.toString(16));
          const ah = (this.regs.AX >> 8) & 0xff;
          if (ah === 0x53) {
            // APM shutdown 要求
            console.log("INT 15h APM shutdown requested");
            // this.halted = true; ← ここをコメントアウト
            return;
          }
        }

        step() {
          if (this.halted) return;
          const op = this.fetch8();
          console.log(
            "CS:IP",
            this.regs.CS.toString(16),
            this.regs.IP.toString(16),
            "op",
            op.toString(16)
          );
          // NOP
          if (op === 0x90) {
            this.cycles++;
            return;
          }

          if (op === 0xcd) {
            console.log("INT instruction");
            const intNum = this.fetch8();
            if (intNum === 0x10) {
              this.handleInt10();
              return;
            }
            if (intNum === 0x16) {
              this.handleInt16();
              return;
            }
            if (intNum === 0x15) {
              this.handleInt15();
              return;
            }
            if (intNum === 0x20) {
              this.halted = true;
              return;
            }
            throw new Error(`INT ${intNum.toString(16)}h 未実装`);
          }
          if ((op & 0xf8) === 0x50) {
            const rn = this.rIndexToName(op & 7);
            const val = this.getReg16(rn);
            this.regs.SP = (this.regs.SP - 2) & 0xffff;
            const phys = ((this.regs.SS << 4) + this.regs.SP) & 0xfffff;
            this.write16(phys, val);
            return;
          }
          // XOR r/m8, r8 (0x30 /r)
          if (op === 0x30) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const src = this.getReg8(reg);
            if (mod === 3) {
              const dst = this.getReg8(rm);
              const res = (dst ^ src) & 0xff;
              this.setReg8(rm, res);
              this.setFlagsLogical(res, 8);
            } else {
              const phys = ((this.regs.DS << 4) + ea) & 0xfffff;
              const dst = this.read8(phys);
              const res = (dst ^ src) & 0xff;
              this.write8(phys, res);
              this.setFlagsLogical(res, 8);
            }
            return;
          }

          // POP r16 (58–5F)
          if ((op & 0xf8) === 0x58) {
            const rn = this.rIndexToName(op & 7);
            const phys = ((this.regs.SS << 4) + this.regs.SP) & 0xfffff;
            const val = this.read16(phys);
            this.regs.SP = (this.regs.SP + 2) & 0xffff;
            this.setReg16(rn, val);
            return;
          }

          // RET (C3) も SS:SP ベースで
          if (op === 0xc3) {
            const phys = ((this.regs.SS << 4) + this.regs.SP) & 0xfffff;
            const ip = this.read16(phys);
            this.regs.SP = (this.regs.SP + 2) & 0xffff;
            this.regs.IP = ip;
            return;
          }
          if (op === 0x08) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const src = this.getReg8(reg);
            let dst;
            if (mod === 3) {
              dst = this.getReg8(rm);
            } else {
              const phys = ((this.regs.DS << 4) + ea) & 0xfffff; // DS:EA
              dst = this.read8(phys);
            }
            const res = (dst | src) & 0xff;
            if (mod === 3) this.setReg8(rm, res);
            else {
              const phys = ((this.regs.DS << 4) + ea) & 0xfffff;
              this.write8(phys, res);
            }
            this.setFlagsLogical(res, 8);
            return;
          }
          if (op === 0x83) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const imm8 = this.fetch8();
            const imm16 = (imm8 << 8) >> 8; // sign-extend
            const cur = this.readOperand16(mod, rm, ea);

            if (reg === 0) {
              // ADD
              const res = (cur + imm16) & 0xffff;
              this.setFlagsArith16("add", cur, imm16, res);
              this.writeOperand16(mod, rm, ea, res);
              return;
            }
            if (reg === 5) {
              // SUB
              const res = (cur - imm16) & 0xffff;
              this.setFlagsArith16("sub", cur, imm16, res);
              this.writeOperand16(mod, rm, ea, res);
              return;
            }
            if (reg === 7) {
              // CMP
              const res = (cur - imm16) & 0xffff;
              this.setFlagsArith16("cmp", cur, imm16, res);
              return;
            }
            throw new Error(`Unsupported 0x83 /${reg}`);
          }

          // MOV r16, imm16 (B8+rw)
          if ((op & 0xf8) === 0xb8) {
            const regIndex = op & 0x07;
            const imm = this.fetch16();
            const rn = this.rIndexToName(regIndex);
            this.setReg16(rn, imm);
            this.cycles += 2;
            return;
          }

          // INC r16 (40-47)
          if ((op & 0xf8) === 0x40) {
            const regIndex = op & 7;
            const rn = this.rIndexToName(regIndex);
            const val = (this.getReg16(rn) + 1) & 0xffff;
            this.setReg16(rn, val);
            this.setFlagsArith16("add", this.getReg16(rn), 1, val);
            this.cycles += 2;
            return;
          }
          // OR r8, r/m8 (0x0A), OR r/m8, r8 (0x08) のどちらも必要
          // とりあえず OR AL,AL 専用の簡易版（汎用は後で）
          if (op === 0x0a) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            // reg は宛先r8、rm がソース r/m8
            const dst = this.getReg8(reg);
            const src =
              mod === 3
                ? this.getReg8(rm)
                : this.read8(((this.regs.DS << 4) + ea) & 0xfffff);
            const res = (dst | src) & 0xff;
            this.setReg8(reg, res);
            this.setFlagsLogical(res, 8);
            return;
          }

          // DEC r16 (48-4F)
          if ((op & 0xf8) === 0x48) {
            const regIndex = op & 7;
            const rn = this.rIndexToName(regIndex);
            const cur = this.getReg16(rn);
            const val = (cur - 1) & 0xffff;
            this.setReg16(rn, val);
            this.setFlagsArith16("sub", cur, 1, val);
            this.cycles += 2;
            return;
          }
          if (op === 0xac) {
            const phys = ((this.regs.DS << 4) + this.regs.SI) & 0xfffff;
            const val = this.read8(phys);
            this.setReg8(0, val); // AL
            this.regs.SI = (this.regs.SI + (this.getDF() ? -1 : 1)) & 0xffff;
            return;
          }

          // MOV r/m16, r16 (89)
          if (op === 0x89) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const src = this.getReg16(this.rIndexToName(reg));
            this.writeOperand16(mod, rm, ea, src);
            this.cycles += 2;
            return;
          }
          if ((op & 0xf8) === 0xb0) {
            const regIndex = op & 7;
            const imm = this.fetch8();
            this.setReg8(regIndex, imm);
            this.cycles += 2;
            return;
          }
          // MOV r16, r/m16 (8B)
          if (op === 0x8b) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const val = this.readOperand16(mod, rm, ea);
            this.setReg16(this.rIndexToName(reg), val);
            this.cycles += 2;
            return;
          }
          // OR r/m16, r16 (09 /r)
          if (op === 0x09) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const src = this.getReg16(this.rIndexToName(reg));
            const dst = this.readOperand16(mod, rm, ea);
            const res = dst | src;
            this.writeOperand16(mod, rm, ea, res);
            this.setFlagsArith16("add", 0, 0, res); // ZF/SF/PF 更新用に流用
            this.FLAGS &= ~((1 << 0) | (1 << 11)); // CF,OFはクリア
            return;
          }

          // XOR r/m16, r16 (31 /r)
          if (op === 0x31) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const src = this.getReg16(this.rIndexToName(reg));
            const dst = this.readOperand16(mod, rm, ea);
            const res = dst ^ src;
            this.writeOperand16(mod, rm, ea, res);
            this.setFlagsArith16("add", 0, 0, res);
            this.FLAGS &= ~((1 << 0) | (1 << 11)); // CF,OF=0
            return;
          }

          // AND r/m16, r16 (21 /r)
          if (op === 0x21) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const src = this.getReg16(this.rIndexToName(reg));
            const dst = this.readOperand16(mod, rm, ea);
            const res = dst & src;
            this.writeOperand16(mod, rm, ea, res);
            this.setFlagsArith16("add", 0, 0, res);
            this.FLAGS &= ~((1 << 0) | (1 << 11));
            return;
          }

          // TEST r/m16, imm16 (F7 /0)
          if (op === 0xf7) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            if (reg === 0) {
              const val = this.readOperand16(mod, rm, ea);
              const imm = this.fetch16();
              const res = val & imm;
              this.setFlagsArith16("add", 0, 0, res);
              this.FLAGS &= ~((1 << 0) | (1 << 11));
              return;
            }
            // 他の /n は後で
          }
          // CMP AL, imm8 (0x3C)
          if (op === 0x3c) {
            const imm = this.fetch8(); // ← 即値を必ず消費！
            const al = this.getReg8(0); // AL
            const res = (al - imm) & 0xff;
            this.setFlagsArith8("cmp", al, imm, res);
            return;
          }

          // SHL r/m16,1 (D1 /4), SHR r/m16,1 (D1 /5)
          if (op === 0xd1) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            let val = this.readOperand16(mod, rm, ea);
            if (reg === 4) {
              // SHL
              const res = (val << 1) & 0xffff;
              this.writeOperand16(mod, rm, ea, res);
              this.setFlagsArith16("add", 0, 0, res);
              return;
            }
            if (reg === 5) {
              // SHR
              const res = (val >>> 1) & 0xffff;
              this.writeOperand16(mod, rm, ea, res);
              this.setFlagsArith16("add", 0, 0, res);
              return;
            }
          }

          // LOOP rel8 (E2)
          if (op === 0xe2) {
            const rel8 = this.sign8(this.fetch8());
            this.regs.CX = (this.regs.CX - 1) & 0xffff;
            if (this.regs.CX !== 0) {
              this.regs.IP = (this.regs.IP + rel8) & 0xffff;
            }
            return;
          }
          // MOV Sreg, r/m16 (8E /r)
          if (op === 0x8e) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const val = this.readOperand16(mod, rm, ea);

            switch (reg) {
              case 0:
                this.regs.ES = val;
                break;
              case 1:
                this.regs.CS = val;
                break;
              case 2:
                this.regs.SS = val;
                break;
              case 3:
                this.regs.DS = val;
                break;
              default:
                throw new Error(
                  `Unsupported segment reg index ${reg} in MOV Sreg,r/m16`
                );
            }

            this.cycles += 2;
            return;
          }

          // JC (72), JNC (73)
          if (op === 0x72 || op === 0x73) {
            const rel8 = this.sign8(this.fetch8());
            const CF = this.FLAGS & 1;
            if ((op === 0x72 && CF) || (op === 0x73 && !CF)) {
              this.regs.IP = (this.regs.IP + rel8) & 0xffff;
            }
            return;
          }

          // MOV r/m16, imm16 (C7 /0)
          if (op === 0xc7) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            if (reg !== 0) throw new Error(`Unsupported C7 /${reg}`);
            const imm = this.fetch16();
            this.writeOperand16(mod, rm, ea, imm);
            this.cycles += 3;
            return;
          }
          // RET (C3)

          // ADD r/m16, imm16 (81 /0) — here we implement only r16 target (mod=3)
          if (op === 0x81) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const imm = this.fetch16();
            if (reg === 0) {
              const cur = this.readOperand16(mod, rm, ea);
              const res = this.setFlagsArith16(
                "add",
                cur,
                imm,
                (cur + imm) & 0xffff
              );
              this.writeOperand16(mod, rm, ea, res);
              this.cycles += 3;
              return;
            }
            if (reg === 5) {
              // SUB
              const cur = this.readOperand16(mod, rm, ea);
              const res = this.setFlagsArith16(
                "sub",
                cur,
                imm,
                (cur - imm) & 0xffff
              );
              this.writeOperand16(mod, rm, ea, res);
              this.cycles += 3;
              return;
            }
            if (reg === 7) {
              // CMP
              const cur = this.readOperand16(mod, rm, ea);
              const res = (cur - imm) & 0xffff;
              this.setFlagsArith16("cmp", cur, imm, res);
              this.cycles += 3;
              return;
            }
            throw new Error(`Unsupported 0x81 /${reg}`);
          }

          // JMP rel16 (E9)
          if (op === 0xe9) {
            const rel = this.fetch16();
            this.regs.IP = (this.regs.IP + this.sign16(rel)) & 0xffff;
            this.cycles += 3;
            return;
          }
          // CALL rel16 (E8)
          if (op === 0xe8) {
            const rel = this.fetch16(); // 符号付き16bitオフセット
            const returnAddr = this.regs.IP & 0xffff;

            // スタックに戻りアドレスを push
            this.regs.SP = (this.regs.SP - 2) & 0xffff;
            this.write16(this.regs.SP, returnAddr);

            // IP をジャンプ先に更新
            this.regs.IP = (this.regs.IP + this.sign16(rel)) & 0xffff;

            this.cycles += 5; // おおよそのサイクル数
            return;
          }
          if (op === 0x74) {
            // JZ rel8
            const rel = (this.fetch8() << 24) >> 24; // sign-extend 8→32
            if (this.getZF()) {
              this.regs.IP = (this.regs.IP + rel) & 0xffff;
            }
            return;
          }
          // JZ rel8 (74)
          if (op === 0x74) {
            const rel8 = this.sign8(this.fetch8());
            const ZF = (this.FLAGS >> 6) & 1;
            if (ZF) this.regs.IP = (this.regs.IP + rel8) & 0xffff;
            this.cycles += 2;
            return;
          }
          if (op === 0x08) {
            const { mod, reg, rm, ea } = this.decodeModRM();
            const src = this.getReg8(reg);
            let dst;
            if (mod === 3) {
              dst = this.getReg8(rm);
              const res = (dst | src) & 0xff;
              this.setReg8(rm, res);
              this.setFlagsLogical(res, 8);
            } else {
              const phys = ((this.regs.DS << 4) + ea) & 0xfffff;
              dst = this.read8(phys);
              const res = (dst | src) & 0xff;
              this.write8(phys, res);
              this.setFlagsLogical(res, 8);
            }
            this.cycles += 3;
            return;
          }
          // JNZ rel8 (75)
          if (op === 0x75) {
            const rel8 = this.sign8(this.fetch8());
            const ZF = (this.FLAGS >> 6) & 1;
            if (!ZF) this.regs.IP = (this.regs.IP + rel8) & 0xffff;
            this.cycles += 2;
            return;
          }
          // JMP rel8 (0xEB)
          if (op === 0xeb) {
            const rel = (this.fetch8() << 24) >> 24; // 符号拡張
            this.regs.IP = (this.regs.IP + rel) & 0xffff;
            this.cycles += 15; // 目安
            return;
          }

          throw new Error(
            `Unsupported opcode 0x${op.toString(16)} at ${this.regs.CS.toString(
              16
            )}:${this.regs.IP.toString(16)}`
          );

          // INT imm8 (CD nn)
        }

        loadBinary(buffer, offset = 0x0000) {
          const src = new Uint8Array(buffer);
          this.mem.set(src, offset);
          this.regs.IP = offset;
          this.halted = false;
        }
      }

      // UI glue for provided HTML
      const cpu = new CPU8086();
      const $bin = document.getElementById("bin");
      const $start = document.getElementById("start");
      const $status = document.getElementById("status");
      const $pc = document.getElementById("pc");
      const $cyc = document.getElementById("cyc");
      const $step = document.getElementById("stepBtn");
      const canvas = document.getElementById("screen");
      const video = new VideoTTY(canvas);
      $bin.addEventListener("change", async (e) => {
        const f = e.target.files?.[0];
        if (!f) return;
        const buf = await f.arrayBuffer();
        cpu.reset();
        cpu.loadBinary(buf, 0x0000);
        $status.textContent = `Loaded ${f.name} (${buf.byteLength} bytes)`;
        $start.disabled = false;
        $step.disabled = false;
      });
      $step.addEventListener("click", () => {
        try {
          // エミュレータから参照できるように
          cpu.video = video;
          if (!cpu.halted) {
            cpu.step();
            cpu.handleInt10 = function () {
              const AH = (this.regs.AX >> 8) & 0xff;
              const AL = this.regs.AX & 0xff;

              if (AH === 0x00) {
                // モードセット (AL=0x03)
                this.video.setTextMode(AL);
                return;
              }
              if (AH === 0x0e) {
                // TTY 出力 (AL=文字コード)
                this.video.putCharTTY(AL);
                return;
              }

              // 未対応の AH は無視する（halt しない）
              console.warn(`INT 10h AH=${AH.toString(16)} 未実装`);
            };

            // HUD 更新
            $pc.textContent = "0x" + cpu.regs.IP.toString(16).padStart(4, "0");
            $cyc.textContent = cpu.cycles;
            $status.textContent = "Stepped 1 instruction";
          } else {
            $status.textContent = "CPU halted";
          }
        } catch (err) {
          $status.textContent = `Error: ${err.message}`;
        }
      });
      let running = false;
      let lastTime = 0;

      function runFrame(timestamp) {
        // エミュレータから参照できるように
        cpu.video = video;
        if (!running) return;

        // 経過時間を計算
        const delta = timestamp - lastTime;
        lastTime = timestamp;
        cpu.handleInt10 = function () {
          console.log("INT 10h", this.regs.AX.toString(16));
          const AH = (this.regs.AX >> 8) & 0xff;
          const AL = this.regs.AX & 0xff;

          if (AH === 0x00) {
            // 画面モード設定（AL=0x03を想定）
            this.video.setTextMode(AL || 3);
            return;
          }
          if (AH === 0x0e) {
            // テレタイプ出力（ページ/色は簡略化）
            this.video.putCharTTY(AL);
            return;
          }

          // 他は必要に応じて
        };
        // 1フレームあたりの命令数を決める（例: 1msあたり500命令）
        const steps = Math.floor(delta * 500);
        for (let i = 0; i < steps && !cpu.halted; i++) {
          cpu.step();
        }

        // HUD 更新
        document.getElementById("pc").textContent =
          "0x" + cpu.regs.IP.toString(16).padStart(4, "0");
        document.getElementById("cyc").textContent = cpu.cycles;

        // 次のフレームを予約
        requestAnimationFrame(runFrame);
      }

      // Start ボタン
      document.getElementById("start").addEventListener("click", () => {
        const canvas = document.getElementById("screen");
        const video = new VideoTTY(canvas);

        // エミュレータから参照できるように
        cpu.video = video;
        if (!running) {
          running = true;
          lastTime = performance.now();
          requestAnimationFrame(runFrame);
          document.getElementById("status").textContent = "Running";
        } else {
          running = false;
          document.getElementById("status").textContent = "Stopped";
        }
      });

      // Optional: fullscreen button to toggle canvas
      document
        .getElementById("fullscreenBtn")
        .addEventListener("click", async () => {
          const canvas = document.getElementById("screen");
          if (document.fullscreenElement) {
            document.exitFullscreen();
          } else {
            await canvas.requestFullscreen();
          }
        });
    </script>
  </body>
</html>
